#!/usr/bin/env ruby
# frozen_string_literal: true

#
# City 911 Emergency Dispatch Center
# A self-adapting system that dynamically creates departments
# and teaches them to handle emergencies they've never seen.
#
# Uses:
#   self_agency          - deliberate method generation via LLM
#   chaos_to_the_rescue  - reactive method generation for unknown calls
#   robot_lab            - LLM-powered robots and workflows
#   typed_bus            - inter-department messaging
#
require "async"
require "bundler/setup"
require_relative "../department"

require "debug_me"
include DebugMe

SEPARATOR    = "=" * 60
THIN_SEP     = "-" * 60

# ---------------------------------------------------------------
# LLM Configuration
# Adjust provider/model to match your setup.
# Defaults to Ollama running locally.
# ---------------------------------------------------------------

LLM_PROVIDER = (ENV["LLM_PROVIDER"] || "ollama").to_sym
LLM_MODEL    = ENV["LLM_MODEL"]    || "qwen3-coder:30b"
LLM_API_BASE = ENV["LLM_API_BASE"] || "http://localhost:11434/v1"

# Patch: Ollama models are local and not in RubyLLM's registry.
# Both self_agency and chaos_to_the_rescue call RubyLLM.chat without
# assume_model_exists, so we inject it here.
module OllamaAssumeExists
  def initialize(model: nil, provider: nil, assume_model_exists: false, context: nil)
    provider            ||= LLM_PROVIDER
    assume_model_exists ||= (provider == :ollama)
    super
  end
end
RubyLLM::Chat.prepend(OllamaAssumeExists)

# Patch: ChaosToTheRescue::Logger lacks .instance but the gem calls it
unless ChaosToTheRescue::Logger.respond_to?(:instance)
  ChaosToTheRescue::Logger.define_singleton_method(:instance) do
    @instance ||= new
  end
end

SelfAgency.configure do |config|
  config.provider        = LLM_PROVIDER
  config.model           = LLM_MODEL
  config.api_base        = LLM_API_BASE
  config.request_timeout = 120
  config.logger          = ->(stage, msg) { Department.shared_logger.debug "[SelfAgency:#{stage}] #{msg}" }
end

ChaosToTheRescue.configure do |config|
  config.enabled             = true
  config.auto_define_methods = true
  config.allow_everything!
  config.model               = LLM_MODEL
  config.log_level           = :info
end

Department.shared_logger.level = :info

# ---------------------------------------------------------------
# 911 Emergencies
# Each has a department type and a specific incident.
# The system has never seen any of these before.
# ---------------------------------------------------------------

EMERGENCIES = [
  { dept: :fire,             incident: :structure_fire,    details: "2-story residential fully engulfed at 123 Main St" },
  { dept: :police,           incident: :burglary,          details: "Break-in in progress at 456 Oak Ave, suspect still on scene" },
  { dept: :ems,              incident: :cardiac_arrest,    details: "Male age 65, unresponsive at 789 Pine Rd" },
  { dept: :fire,             incident: :hazmat_spill,      details: "Chemical tanker overturned on Highway 101, fumes reported" },
  { dept: :animal_control,   incident: :aggressive_animal, details: "Loose aggressive dog near playground in Riverside Park" },
  { dept: :public_works,     incident: :sinkhole,          details: "Large sinkhole opened on 5th Street, road impassable" },
  { dept: :police,           incident: :traffic_accident,  details: "Multi-vehicle pileup with injuries on I-95 southbound" },
  { dept: :ems,              incident: :allergic_reaction,  details: "Child age 8, severe allergic reaction at Elm Elementary" },
  { dept: :code_enforcement, incident: :illegal_dumping,   details: "Hazardous waste dumped behind 321 Warehouse Blvd" },
  { dept: :fire,             incident: :wildfire,          details: "Brush fire approaching homes on Ridge Road, winds 30mph" },
  { dept: :police,           incident: :domestic_dispute,  details: "Neighbor reports screaming at 555 Birch Lane apt 3B" },
  { dept: :public_works,     incident: :water_main_break,  details: "Major water main break flooding intersection at 2nd and Elm" },
].freeze

# ---------------------------------------------------------------
# City 911 Dispatch Center
# ---------------------------------------------------------------

class City911Center
  attr_reader :departments, :dispatch_log

  def initialize
    @departments  = {}
    @dispatch_log = []
  end

  def dispatch(emergency)
    dept   = find_or_create_department(emergency[:dept])
    method = :"handle_#{emergency[:incident]}"

    already_known = dept.class.method_defined?(method)

    puts <<~BANNER
      #{THIN_SEP}
        Dispatching to: #{dept.name}
        Method:         #{method}
        Known method:   #{already_known ? 'YES' : 'NO -- generating via chaos_to_the_rescue'}
        Details:        #{emergency[:details]}
      #{THIN_SEP}
    BANNER

    start  = Process.clock_gettime(Process::CLOCK_MONOTONIC)
    result = dept.public_send(method, emergency[:details])
    elapsed = (Process.clock_gettime(Process::CLOCK_MONOTONIC) - start).round(2)

    debug_me "  Completed in #{elapsed}s"

    @dispatch_log << {
      call_number: @dispatch_log.size + 1,
      emergency:   emergency,
      department:  dept.name,
      method:      method,
      was_new:     !already_known,
      result:      result,
      elapsed:     elapsed
    }

    result
  rescue => e
    debug_me "  ERROR dispatching #{emergency[:incident]}: #{e.class} - #{e.message}"
    nil
  end

  def print_summary
    puts <<~HEADER

      #{SEPARATOR}
        DISPATCH SUMMARY
      #{SEPARATOR}

        Total 911 calls handled:  #{@dispatch_log.size}
        Departments created:      #{@departments.size}
        Methods generated:        #{@dispatch_log.count { |e| e[:was_new] }}

    HEADER

    @departments.each do |type, dept|
      entries = @dispatch_log.select { |e| e[:emergency][:dept] == type }
      handlers = entries.map { |e| e[:method] }.uniq.sort
      puts <<~DEPT
        #{dept.name} (#{handlers.size} handlers):
        #{handlers.map { |m| "    - #{m}" }.join("\n")}

      DEPT
    end
  end

  def demonstrate_self_agency(dept_type, description)
    dept = @departments[dept_type]
    return debug_me("  No #{dept_type} department exists yet") unless dept

    puts <<~BANNER
      #{THIN_SEP}
        SELF-AGENCY: #{dept.name} deliberately learning a new capability
        Description: #{description}
      #{THIN_SEP}
    BANNER

    start   = Process.clock_gettime(Process::CLOCK_MONOTONIC)
    methods = dept._(description)
    elapsed = (Process.clock_gettime(Process::CLOCK_MONOTONIC) - start).round(2)

    debug_me "  Learned #{methods.inspect} in #{elapsed}s"
    methods
  rescue => e
    debug_me "  ERROR in self_agency: #{e.class} - #{e.message}"
    nil
  end

  private

  def find_or_create_department(type)
    return @departments[type] if @departments.key?(type)

    const_name = type.to_s.split("_").map(&:capitalize).join + "Department"
    dept_class = Department.dup
    Object.const_set(const_name, dept_class) unless Object.const_defined?(const_name)
    dept_class.department_name = format_name(type)

    dept = dept_class.new

    # Give it a coordinator robot
    dept.create_robot(:coordinator,
      system_prompt: "You are the coordinator for the #{dept.name}. " \
                     "You help manage resources, prioritize incidents, " \
                     "and coordinate with other departments."
    )

    puts <<~BANNER

      #{SEPARATOR}
        NEW DEPARTMENT CREATED: #{dept.name}
        Class:       #{const_name}
        Coordinator: #{dept.name}:coordinator
      #{SEPARATOR}

    BANNER

    @departments[type] = dept
  end

  def format_name(type)
    type.to_s.split("_").map(&:capitalize).join(" ") + " Department"
  end
end

# ---------------------------------------------------------------
# Main
# ---------------------------------------------------------------

puts <<~HEADER
  #{SEPARATOR}
    CITY 911 EMERGENCY DISPATCH CENTER
    Self-Adapting Department System
  #{SEPARATOR}

    LLM Provider: #{LLM_PROVIDER}
    LLM Model:    #{LLM_MODEL}
    Emergencies:  #{EMERGENCIES.size}

HEADER

center = City911Center.new

# Phase 1: Process 911 calls
# Departments and handler methods are created on demand.

debug_me "PHASE 1: Incoming 911 Calls"
debug_me "Departments and methods will be created as needed.\n"

EMERGENCIES.shuffle(random: Random.new(42)).each_with_index do |emergency, index|
  puts <<~CALL

    #{SEPARATOR}
      911 CALL ##{index + 1} of #{EMERGENCIES.size}
      Type: #{emergency[:incident].to_s.tr('_', ' ').upcase}
    #{SEPARATOR}
  CALL

  center.dispatch(emergency)
end

# Phase 2: Departments proactively learn new capabilities via self_agency

debug_me "\nPHASE 2: Proactive Learning via Self-Agency"
debug_me "Departments deliberately acquire new capabilities.\n"

center.demonstrate_self_agency(
  :fire,
  "a method called resource_status that returns a Hash " \
  "with keys :engines, :personnel, :water_supply each with an Integer value"
)

center.demonstrate_self_agency(
  :ems,
  "a method called triage_priority that accepts a description String " \
  "and returns one of these symbols: :critical, :urgent, or :stable " \
  "based on keywords in the description"
)

# Phase 3: Inter-department communication demo

debug_me "\nPHASE 3: Inter-Department Communication"
debug_me "Departments communicate via the shared TypedBus.\n"

Async do
  channel_name = :mutual_aid

  unless Department.shared_bus.channel?(channel_name)
    Department.shared_bus.add_channel(channel_name, type: Hash, timeout: 10)
  end

  responders = []

  center.departments.each do |type, dept|
    id = dept.listen(channel_name) do |delivery|
      debug_me "  #{dept.name} received mutual aid request: #{delivery.message[:description]}"
      delivery.ack!
    end
    responders << [dept, id]
  end

  fire = center.departments[:fire]
  if fire
    request = {
      from:        fire.name,
      description: "Structure collapse with trapped occupants -- need all available units",
      priority:    :critical
    }
    debug_me "  #{fire.name} broadcasting mutual aid request..."
    fire.broadcast(channel_name, request)
  end
end

# Summary

center.print_summary

# Phase 4: Save departments to source files

debug_me "\nPHASE 4: Saving Department Source Files"
debug_me "Each department saves itself as a Ruby class file.\n"

center.departments.each do |type, dept|
  path = dept.save_source!
  debug_me "  Saved #{dept.name} -> #{path}"
end
