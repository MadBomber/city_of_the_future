#!/usr/bin/env ruby
# frozen_string_literal: true

#
# City 911 Emergency Dispatch Center
# A self-adapting system that dynamically creates departments
# and teaches them to handle emergencies they've never seen.
#
# Uses:
#   self_agency          - deliberate method generation via LLM
#   chaos_to_the_rescue  - reactive method generation for unknown calls
#   robot_lab            - LLM-powered robots and workflows
#   typed_bus            - inter-department messaging with typed channels
#   vsm                  - Viable System Model capsule for structured dispatch
#
require "async"
require "bundler/setup"
require_relative "../department"
require_relative "../bus_setup"
require_relative "../tools/dispatch_tool"
require_relative "../tools/resource_query_tool"
require "vsm"

require "debug_me"
include DebugMe

SEPARATOR    = "=" * 60
THIN_SEP     = "-" * 60

# ---------------------------------------------------------------
# LLM Configuration
# Adjust provider/model to match your setup.
# Defaults to Ollama running locally.
# ---------------------------------------------------------------

LLM_PROVIDER = (ENV["LLM_PROVIDER"] || "ollama").to_sym
LLM_MODEL    = ENV["LLM_MODEL"]    || "qwen3-coder:30b"
LLM_API_BASE = ENV["LLM_API_BASE"] || "http://localhost:11434/v1"

# Patch: Ollama models are local and not in RubyLLM's registry.
# Both self_agency and chaos_to_the_rescue call RubyLLM.chat without
# assume_model_exists, so we inject it here.
module OllamaAssumeExists
  def initialize(model: nil, provider: nil, assume_model_exists: false, context: nil)
    provider            ||= LLM_PROVIDER
    assume_model_exists ||= (provider == :ollama)
    super
  end
end
RubyLLM::Chat.prepend(OllamaAssumeExists)

# Patch: ChaosToTheRescue::Logger lacks .instance but the gem calls it
unless ChaosToTheRescue::Logger.respond_to?(:instance)
  ChaosToTheRescue::Logger.define_singleton_method(:instance) do
    @instance ||= new
  end
end

SelfAgency.configure do |config|
  config.provider        = LLM_PROVIDER
  config.model           = LLM_MODEL
  config.api_base        = LLM_API_BASE
  config.request_timeout = 300
  config.logger          = ->(stage, msg) { Department.shared_logger.debug "[SelfAgency:#{stage}] #{msg}" }
end

ChaosToTheRescue.configure do |config|
  config.enabled             = true
  config.auto_define_methods = true
  config.allow_everything!
  config.model               = LLM_MODEL
  config.log_level           = :info
end

RobotLab.configure do |config|
  config.default_provider = LLM_PROVIDER
  config.default_model    = LLM_MODEL
end

Department.shared_logger.level = :info

# ---------------------------------------------------------------
# Setup: Configure shared bus with typed channels
# ---------------------------------------------------------------

Department.attach(Department.shared_bus)

# ---------------------------------------------------------------
# City-wide reactive memory via RobotLab
# ---------------------------------------------------------------

CITY_MEMORY = RobotLab.create_memory(data: {
  active_incidents: 0,
  departments:      {},
  total_dispatches: 0
})

# ---------------------------------------------------------------
# 911 Emergencies
# Each has a department type and a specific incident.
# The system has never seen any of these before.
# ---------------------------------------------------------------

EMERGENCIES = [
  { dept: :fire,             incident: :structure_fire,    details: "2-story residential fully engulfed at 123 Main St" },
  { dept: :police,           incident: :burglary,          details: "Break-in in progress at 456 Oak Ave, suspect still on scene" },
  { dept: :ems,              incident: :cardiac_arrest,    details: "Male age 65, unresponsive at 789 Pine Rd" },
  { dept: :fire,             incident: :hazmat_spill,      details: "Chemical tanker overturned on Highway 101, fumes reported" },
  { dept: :animal_control,   incident: :aggressive_animal, details: "Loose aggressive dog near playground in Riverside Park" },
  { dept: :public_works,     incident: :sinkhole,          details: "Large sinkhole opened on 5th Street, road impassable" },
  { dept: :police,           incident: :traffic_accident,  details: "Multi-vehicle pileup with injuries on I-95 southbound" },
  { dept: :ems,              incident: :allergic_reaction,  details: "Child age 8, severe allergic reaction at Elm Elementary" },
  { dept: :code_enforcement, incident: :illegal_dumping,   details: "Hazardous waste dumped behind 321 Warehouse Blvd" },
  { dept: :fire,             incident: :wildfire,          details: "Brush fire approaching homes on Ridge Road, winds 30mph" },
  { dept: :police,           incident: :domestic_dispute,  details: "Neighbor reports screaming at 555 Birch Lane apt 3B" },
  { dept: :public_works,     incident: :water_main_break,  details: "Major water main break flooding intersection at 2nd and Elm" },
].freeze

# ---------------------------------------------------------------
# City 911 Dispatch Center
# ---------------------------------------------------------------

class City911Center
  attr_reader :departments, :dispatch_log

  def initialize
    @departments  = {}
    @dispatch_log = []
    @call_counter = 0
  end

  def dispatch(emergency)
    dept   = find_or_create_department(emergency[:dept])
    method = :"handle_#{emergency[:incident]}"
    @call_counter += 1
    call_id = @call_counter

    already_known = dept.class.method_defined?(method)

    puts <<~BANNER
      #{THIN_SEP}
        Dispatching to: #{dept.name}
        Method:         #{method}
        Known method:   #{already_known ? 'YES' : 'NO -- generating via chaos_to_the_rescue'}
        Details:        #{emergency[:details]}
      #{THIN_SEP}
    BANNER

    # Publish typed IncidentReport on the shared bus
    Async do
      dept.broadcast_incident(
        call_id:  call_id,
        incident: emergency[:incident],
        details:  emergency[:details],
        severity: :normal
      )
    end

    start  = Process.clock_gettime(Process::CLOCK_MONOTONIC)
    result = dept.public_send(method, emergency[:details])
    elapsed = (Process.clock_gettime(Process::CLOCK_MONOTONIC) - start).round(2)

    debug_me "  Completed in #{elapsed}s"

    # Publish typed DispatchResult on the shared bus
    Async do
      dept.broadcast_dispatch_result(
        call_id: call_id,
        method:  method,
        result:  result.to_s[0, 200],
        was_new: !already_known,
        elapsed: elapsed
      )
    end

    # Update city memory
    CITY_MEMORY.set(:active_incidents, CITY_MEMORY.get(:active_incidents).to_i + 1)
    CITY_MEMORY.set(:total_dispatches, CITY_MEMORY.get(:total_dispatches).to_i + 1)
    dept_data = CITY_MEMORY.get(:departments) || {}
    dept_data[emergency[:dept]] = { handlers: dept.generated_methods.size }
    CITY_MEMORY.set(:departments, dept_data)

    @dispatch_log << {
      call_number: call_id,
      emergency:   emergency,
      department:  dept.name,
      method:      method,
      was_new:     !already_known,
      result:      result,
      elapsed:     elapsed
    }

    result
  rescue => e
    debug_me "  ERROR dispatching #{emergency[:incident]}: #{e.class} - #{e.message}"
    nil
  end

  def robot_analyze(emergency)
    dept = find_or_create_department(emergency[:dept])
    robot = dept.robot(:coordinator)
    return debug_me("  No coordinator robot for #{dept.name}") unless robot

    puts <<~BANNER
      #{THIN_SEP}
        ROBOT ANALYSIS: #{dept.name} coordinator analyzing incident
        Incident: #{emergency[:incident]}
        Details:  #{emergency[:details]}
      #{THIN_SEP}
    BANNER

    start  = Process.clock_gettime(Process::CLOCK_MONOTONIC)
    result = robot.run(message: <<~PROMPT)
      Analyze this 911 incident and suggest a priority level (critical/high/normal).
      Also recommend the number of units to dispatch.

      Incident type: #{emergency[:incident]}
      Details: #{emergency[:details]}

      Respond with:
      PRIORITY: <level>
      UNITS: <number>
      REASONING: <brief explanation>
    PROMPT
    elapsed = (Process.clock_gettime(Process::CLOCK_MONOTONIC) - start).round(2)

    text = result.last_text_content
    debug_me "  Robot analysis (#{elapsed}s):\n#{text}"
    text
  rescue => e
    debug_me "  ERROR in robot analysis: #{e.class} - #{e.message}"
    nil
  end

  def run_triage_network(emergency)
    dept = find_or_create_department(emergency[:dept])

    classifier = dept.robot(:coordinator)
    return debug_me("  No coordinator robot for triage") unless classifier

    # Build a triage network with classify -> recommend pipeline
    triage = dept.create_network(:triage) do
      task :classify, classifier, depends_on: :none
      task :recommend, classifier, depends_on: [:classify]
    end

    puts <<~BANNER
      #{THIN_SEP}
        TRIAGE NETWORK: #{dept.name} running multi-step analysis
        Network: #{dept.name}:triage
      #{THIN_SEP}
    BANNER

    start  = Process.clock_gettime(Process::CLOCK_MONOTONIC)
    result = triage.run(
      message: "Classify this emergency and recommend a response plan: " \
               "#{emergency[:incident]} - #{emergency[:details]}"
    )
    elapsed = (Process.clock_gettime(Process::CLOCK_MONOTONIC) - start).round(2)

    text = result.value&.last_text_content
    debug_me "  Triage result (#{elapsed}s):\n#{text}"
    text
  rescue => e
    debug_me "  ERROR in triage network: #{e.class} - #{e.message}"
    nil
  end

  def print_summary
    puts <<~HEADER

      #{SEPARATOR}
        DISPATCH SUMMARY
      #{SEPARATOR}

        Total 911 calls handled:  #{@dispatch_log.size}
        Departments created:      #{@departments.size}
        Methods generated:        #{@dispatch_log.count { |e| e[:was_new] }}

    HEADER

    @departments.each do |type, dept|
      entries = @dispatch_log.select { |e| e[:emergency][:dept] == type }
      handlers = entries.map { |e| e[:method] }.uniq.sort
      puts <<~DEPT
        #{dept.name} (#{handlers.size} handlers):
        #{handlers.map { |m| "    - #{m}" }.join("\n")}

      DEPT
    end
  end

  def demonstrate_self_agency(dept_type, description)
    dept = @departments[dept_type]
    return debug_me("  No #{dept_type} department exists yet") unless dept

    puts <<~BANNER
      #{THIN_SEP}
        SELF-AGENCY: #{dept.name} deliberately learning a new capability
        Description: #{description}
      #{THIN_SEP}
    BANNER

    start   = Process.clock_gettime(Process::CLOCK_MONOTONIC)
    methods = dept._(description)
    elapsed = (Process.clock_gettime(Process::CLOCK_MONOTONIC) - start).round(2)

    debug_me "  Learned #{methods.inspect} in #{elapsed}s"

    # Publish MethodGenerated for each new method
    Array(methods).each do |m|
      source = dept.generated_source(m)
      Async do
        dept.broadcast_method_generated(
          method_name:  m,
          scope:        :instance,
          source_lines: source&.lines&.size || 0
        )
      end
    end

    methods
  rescue => e
    debug_me "  ERROR in self_agency: #{e.class} - #{e.message}"
    nil
  end

  private

  def find_or_create_department(type)
    return @departments[type] if @departments.key?(type)

    const_name = type.to_s.split("_").map(&:capitalize).join + "Department"
    dept_class = Department.dup
    Object.const_set(const_name, dept_class) unless Object.const_defined?(const_name)
    dept_class.department_name = format_name(type)

    dept = dept_class.new

    # Give it a coordinator robot
    dept.create_robot(:coordinator,
      system_prompt: "You are the coordinator for the #{dept.name}. " \
                     "You help manage resources, prioritize incidents, " \
                     "and coordinate with other departments."
    )

    puts <<~BANNER

      #{SEPARATOR}
        NEW DEPARTMENT CREATED: #{dept.name}
        Class:       #{const_name}
        Coordinator: #{dept.name}:coordinator
      #{SEPARATOR}

    BANNER

    @departments[type] = dept
  end

  def format_name(type)
    type.to_s.split("_").map(&:capitalize).join(" ") + " Department"
  end
end

# ---------------------------------------------------------------
# Main
# ---------------------------------------------------------------

puts <<~HEADER
  #{SEPARATOR}
    CITY 911 EMERGENCY DISPATCH CENTER
    Self-Adapting Department System
  #{SEPARATOR}

    LLM Provider: #{LLM_PROVIDER}
    LLM Model:    #{LLM_MODEL}
    Emergencies:  #{EMERGENCIES.size}

    Typed Bus Channels: #{BusSetup::CHANNELS.keys.join(", ")}

HEADER

center = City911Center.new

# ---------------------------------------------------------------
# Phase 1: Reactive Dispatch via chaos_to_the_rescue
# Departments and handler methods are created on demand.
# Typed IncidentReport and DispatchResult messages flow on the bus.
# ---------------------------------------------------------------

debug_me "PHASE 1: Incoming 911 Calls (Reactive Dispatch)"
debug_me "Departments and methods will be created as needed."
debug_me "Typed messages (IncidentReport, DispatchResult) publish on the shared bus.\n"

# Subscribe to typed channels to show messages flowing
incident_sub = nil
dispatch_sub = nil

Async do
  incident_sub = Department.shared_bus.subscribe(:incidents) do |delivery|
    msg = delivery.message
    debug_me "  [BUS] IncidentReport: #{msg.department} / #{msg.incident} (severity: #{msg.severity})"
    delivery.ack!
  end

  dispatch_sub = Department.shared_bus.subscribe(:dispatch_results) do |delivery|
    msg = delivery.message
    debug_me "  [BUS] DispatchResult: #{msg.department} / #{msg.method} (#{msg.elapsed}s, new: #{msg.was_new})"
    delivery.ack!
  end
end

EMERGENCIES.shuffle(random: Random.new(42)).each_with_index do |emergency, index|
  puts <<~CALL

    #{SEPARATOR}
      911 CALL ##{index + 1} of #{EMERGENCIES.size}
      Type: #{emergency[:incident].to_s.tr('_', ' ').upcase}
    #{SEPARATOR}
  CALL

  center.dispatch(emergency)
end

# ---------------------------------------------------------------
# Phase 2: Robot Analysis
# Use coordinator robot to analyze an incident before dispatch.
# Demonstrates robot_lab.run() with meaningful prompts.
# ---------------------------------------------------------------

debug_me "\nPHASE 2: Robot Analysis"
debug_me "Using coordinator robots to analyze incidents.\n"

center.robot_analyze(
  { dept: :fire, incident: :structure_fire, details: "High-rise commercial building, 15 floors, smoke from 8th floor" }
)

# Run triage network for a complex multi-step analysis
center.run_triage_network(
  { dept: :police, incident: :hostage_situation, details: "Armed suspect barricaded in bank with 12 hostages" }
)

# ---------------------------------------------------------------
# Phase 3: Self-Agency Learning
# Departments deliberately acquire new capabilities.
# Publishes MethodGenerated messages on typed channels.
# ---------------------------------------------------------------

debug_me "\nPHASE 3: Proactive Learning via Self-Agency"
debug_me "Departments deliberately acquire new capabilities.\n"

method_sub = nil
Async do
  method_sub = Department.shared_bus.subscribe(:method_generated) do |delivery|
    msg = delivery.message
    debug_me "  [BUS] MethodGenerated: #{msg.department} learned #{msg.method_name} (#{msg.source_lines} lines)"
    delivery.ack!
  end
end

center.demonstrate_self_agency(
  :fire,
  "a method called resource_status that returns a Hash " \
  "with keys :engines, :personnel, :water_supply each with an Integer value"
)

center.demonstrate_self_agency(
  :ems,
  "a method called triage_priority that accepts a description String " \
  "and returns one of these symbols: :critical, :urgent, or :stable " \
  "based on keywords in the description. " \
  "Use only pure string matching logic with no IO, no shell calls, and no metaprogramming"
)

# ---------------------------------------------------------------
# Phase 4: VSM-Driven Dispatch
# Build a VSM Capsule wrapping the 911 center with ToolCapsules.
# Shows Intelligence -> Operations -> ToolCapsule -> dispatch flow.
# ---------------------------------------------------------------

debug_me "\nPHASE 4: VSM-Driven Dispatch"
debug_me "Building a Viable System Model capsule for structured dispatch.\n"

# Create an OpenAI-compatible driver for VSM Intelligence
driver = VSM::Drivers::OpenAI::AsyncDriver.new(
  api_key:  ENV["LLM_API_KEY"] || "ollama",
  model:    LLM_MODEL,
  base_url: LLM_API_BASE
)

# Build tool capsule instances and inject dependencies
dispatch_tool = DispatchTool.new
dispatch_tool.center = center

resource_tool = ResourceQueryTool.new
resource_tool.city_memory = CITY_MEMORY

# Build the VSM capsule
vsm_capsule = VSM::DSL.define(:city_911) do
  identity    klass: VSM::Identity, args: {
    identity: "City 911 Emergency Dispatch",
    invariants: ["All emergencies must be dispatched", "Prioritize life-threatening incidents"]
  }
  governance   klass: VSM::Governance
  coordination klass: VSM::Coordination
  intelligence klass: VSM::Intelligence, args: {
    driver: driver,
    system_prompt: "You are the City 911 Emergency Dispatch coordinator. " \
                   "You have two tools: 'dispatch' to send emergencies to departments, " \
                   "and 'query_resources' to check department availability. " \
                   "When given an emergency, use the dispatch tool to handle it. " \
                   "Respond briefly after dispatching."
  }
  operations do
    capsule :dispatch,        klass: DispatchTool
    capsule :query_resources, klass: ResourceQueryTool
  end
end

# Inject dependencies into the capsule's operation children
vsm_capsule.children["dispatch"].center = center
vsm_capsule.children["query_resources"].city_memory = CITY_MEMORY

puts <<~VSM_INFO
  #{SEPARATOR}
    VSM CAPSULE BUILT: #{vsm_capsule.name}
    Roles:    #{vsm_capsule.roles.keys.join(", ")}
    Tools:    #{vsm_capsule.children.keys.join(", ")}
  #{SEPARATOR}

VSM_INFO

# Feed an emergency through the VSM capsule
vsm_emergency = {
  dept: :ems,
  incident: :mass_casualty,
  details: "Bus accident on Highway 5, approximately 20 injured passengers"
}

debug_me "Feeding emergency through VSM capsule: #{vsm_emergency[:incident]}"

session_id = SecureRandom.uuid
collected_output = []

# Subscribe to capsule bus to collect output
vsm_capsule.bus.subscribe do |msg|
  case msg.kind
  when :assistant
    collected_output << msg.payload.to_s unless msg.payload.to_s.empty?
    debug_me "  [VSM] Assistant: #{msg.payload.to_s[0, 200]}"
  when :tool_call
    debug_me "  [VSM] Tool call: #{msg.payload[:tool]}(#{msg.payload[:args]})"
  when :tool_result
    debug_me "  [VSM] Tool result: #{msg.payload.to_s[0, 200]}"
  end
end

# Run the capsule with the emergency
Async do |task|
  vsm_capsule.bus.emit(VSM::Message.new(
    kind: :user,
    payload: "Emergency: #{vsm_emergency[:incident].to_s.tr('_', ' ')}. " \
             "Department: #{vsm_emergency[:dept]}. " \
             "Details: #{vsm_emergency[:details]}. " \
             "Please dispatch this emergency.",
    meta: { session_id: session_id }
  ))

  # Let the capsule process the message
  capsule_task = vsm_capsule.run

  # Give the async tasks time to complete, then stop the capsule loop
  task.sleep(30)
  capsule_task.stop
rescue => e
  debug_me "  VSM error: #{e.class} - #{e.message}"
end

# ---------------------------------------------------------------
# Phase 5: Inter-Department Communication (Typed Messages)
# Uses MutualAidRequest typed messages instead of raw Hash.
# ---------------------------------------------------------------

debug_me "\nPHASE 5: Inter-Department Communication"
debug_me "Departments communicate via typed MutualAidRequest messages.\n"

Async do
  responders = []

  center.departments.each do |type, dept|
    id = dept.listen(:mutual_aid) do |delivery|
      msg = delivery.message
      debug_me "  #{dept.name} received mutual aid request from #{msg.from_department}: #{msg.description}"
      delivery.ack!
    end
    responders << [dept, id]
  end

  fire = center.departments[:fire]
  if fire
    request = MutualAidRequest.new(
      from_department: fire.name,
      description:     "Structure collapse with trapped occupants -- need all available units",
      priority:        :critical,
      call_id:         99
    )
    debug_me "  #{fire.name} broadcasting mutual aid request..."
    fire.broadcast(:mutual_aid, request)
  end
end

# ---------------------------------------------------------------
# Summary
# ---------------------------------------------------------------

center.print_summary

# City memory summary
debug_me "\nCity Memory State:"
debug_me "  Active incidents: #{CITY_MEMORY.get(:active_incidents)}"
debug_me "  Total dispatches: #{CITY_MEMORY.get(:total_dispatches)}"
dept_data = CITY_MEMORY.get(:departments) || {}
dept_data.each do |type, info|
  debug_me "  #{type}: #{info[:handlers]} handlers"
end

# ---------------------------------------------------------------
# Phase 6: Save Department Source Files
# ---------------------------------------------------------------

debug_me "\nPHASE 6: Saving Department Source Files"
debug_me "Each department saves itself as a Ruby class file.\n"

center.departments.each do |type, dept|
  path = dept.save_source!
  debug_me "  Saved #{dept.name} -> #{path}"
end
