#!/usr/bin/env ruby

require "bundler/setup"
require "lumberjack"
require "async"
require "optparse"

options = { replay: false, voice: ENV["VOICE"] != "off" }

OptionParser.new do |opts|
  opts.banner = "Usage: demo [options]"
  opts.on("--replay", "Run the scenario player with pre-scripted calls") { options[:replay] = true }
  opts.on("--no-voice", "Disable text-to-speech output")                { options[:voice] = false }
end.parse!

require_relative "../lib/bus_setup"
require_relative "../lib/llm_mode"

# --- Logger ---

FileUtils.mkdir_p("log")

$logger = Lumberjack::Logger.new(
  "log/demo.log",
  level:      :info,
  buffer_size: 0
)

$logger.info "Demo starting (pid #{Process.pid})"

# --- Bus ---

bus = BusSetup.create_bus(logger: $logger)
$logger.info "Bus created with #{bus.channel_names.size} channels: #{bus.channel_names.join(', ')}"

# --- LLM mode ---

mode          = ENV.fetch("LLM_MODE", "replay")
scenario_path = ENV["SCENARIO_PATH"]
scenario_path = nil if scenario_path&.empty?

handler = LLMMode.setup(bus, mode: mode, scenario_path: scenario_path, logger: $logger)
$logger.info "LLM handler attached in #{mode} mode (#{handler.class})"

# --- Voice I/O ---

require_relative "../lib/voice/speaker"

speaker = Speaker.new(logger: $logger, enabled: options[:voice])
speaker.attach(bus)
$logger.info "Speaker attached (enabled: #{options[:voice]})"

# --- VSM Capsule (Layer 5) ---

require_relative "../lib/departments"
require_relative "../lib/vsm/intelligence"
require_relative "../lib/vsm/operations"

fire    = FireDepartment.new
police  = PoliceDepartment.new
ems     = EMS.new
utils   = Utilities.new
council = CityCouncil.new

intelligence = Intelligence.new(logger: $logger)
intelligence.attach(bus)
$logger.info "Intelligence attached"

operations = Operations.new(logger: $logger)
[fire, police, ems, utils, council].each { |dept| operations.register(dept) }
operations.attach(bus)
$logger.info "Operations attached with #{[fire, police, ems, utils, council].size} departments"

# --- Autonomy (Layer 4) ---

require_relative "../lib/autonomy/governance"
require_relative "../lib/autonomy/chaos_bridge"
require_relative "../lib/autonomy/self_agency_bridge"

governance = Governance.new(logger: $logger)
governance.attach(bus)
$logger.info "Governance attached"

# Code generation robot — always use ReplayRobot so the autonomy
# demo is reliable regardless of LLM availability
require_relative "../lib/llm/replay_robot"
robot_path = File.expand_path("../scenarios/demo_robot.yml", __dir__)
code_gen_robot = ReplayRobot.new(robot_path, logger: $logger)
$logger.info "Using ReplayRobot for code generation"

chaos = ChaosBridge.new(robot: code_gen_robot, logger: $logger)
chaos.attach(bus)
chaos.watch(FireDepartment)
chaos.watch(PoliceDepartment)
chaos.watch(EMS)
chaos.watch(Utilities)
chaos.watch(CityCouncil)
$logger.info "ChaosBridge attached (watching 5 department classes)"

agency = SelfAgencyBridge.new(robot: code_gen_robot, logger: $logger)
agency.attach(bus)
$logger.info "SelfAgencyBridge attached"

# --- Web Dashboard ---

require_relative "../lib/web/display_bridge"
require_relative "../web/app"

display_bridge = DisplayBridge.new
display_bridge.attach(bus)

call_queue = Thread::Queue.new

dashboard_port = ENV.fetch("DASHBOARD_PORT", "4567").to_i
DashboardApp.set :bridge, display_bridge
DashboardApp.set :bus, bus
DashboardApp.set :call_queue, call_queue
DashboardApp.set :port, dashboard_port
DashboardApp.set :bind, "0.0.0.0"
DashboardApp.set :environment, :production

web_thread = Thread.new do
  DashboardApp.run!
rescue => e
  $logger.error "Dashboard error: #{e.message}"
end

$logger.info "Dashboard starting on http://localhost:#{dashboard_port}"

# --- Scenario Player (optional) ---

require_relative "../lib/scenario/player"

player = nil

if options[:replay]
  calls_path = ENV.fetch("DEMO_CALLS", File.expand_path("../scenarios/demo_calls.yml", __dir__))

  player = ScenarioPlayer.new(scenario_path: calls_path, logger: $logger)
  player.attach(bus)
  player.on_phase { |name| $logger.info "=== PHASE: #{name} ===" }
  $logger.info "ScenarioPlayer loaded (#{calls_path})"
else
  $logger.info "No scenario player — waiting for live input"
end

# --- Signal handling ---

shutdown = false

%w[TERM INT].each do |sig|
  trap(sig) do
    shutdown = true
  end
end

# --- Main loop ---

$logger.info "Demo ready#{player ? ', starting scenario...' : ', waiting for input...'}"

Async do
  # Drain dashboard call queue into the bus (runs in Async context)
  live_call_count = 0
  caller_voices = ScenarioPlayer::CALLER_VOICES

  queue_task = Async do
    until shutdown
      while (call = call_queue.pop(true) rescue nil)
        $logger.info "Dashboard call: [#{call.call_id}] #{call.caller} — #{call.description[0..60]}"

        bus.publish(:voice_out, VoiceOut.new(
          text:       call.description,
          voice:      caller_voices[live_call_count % caller_voices.size],
          department: "Caller",
          priority:   2
        ))

        bus.publish(:calls, call)
        live_call_count += 1
      end
      sleep 0.1
    end
  end

  if player
    scenario_task = Async do
      player.play
      $logger.info "Scenario playback finished"
    end

    loop do
      break if shutdown
      break if scenario_task.finished?
      sleep 0.25
    end

    # Allow time for final messages to propagate (autonomy pipeline needs time)
    sleep 5 unless shutdown
  else
    # Live mode — run until shutdown signal
    sleep 0.25 until shutdown
  end

  queue_task.stop
end

# --- Cleanup ---

$logger.info "Shutting down..."
handler.close if handler.respond_to?(:close)
bus.close_all
$logger.info "Demo stopped."
$logger.close
