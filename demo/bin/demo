#!/usr/bin/env ruby

require "bundler/setup"
require "lumberjack"
require "async"

require_relative "../lib/bus_setup"
require_relative "../lib/llm_mode"

# --- Logger ---

FileUtils.mkdir_p("log")

$logger = Lumberjack::Logger.new(
  "log/demo.log",
  level:      :info,
  buffer_size: 0
)

$logger.info "Demo starting (pid #{Process.pid})"

# --- Bus ---

bus = BusSetup.create_bus
$logger.info "Bus created with #{bus.channel_names.size} channels: #{bus.channel_names.join(', ')}"

# --- LLM mode ---

mode          = ENV.fetch("LLM_MODE", "replay")
scenario_path = ENV["SCENARIO_PATH"]
scenario_path = nil if scenario_path&.empty?

handler = LLMMode.setup(bus, mode: mode, scenario_path: scenario_path)
$logger.info "LLM handler attached in #{mode} mode (#{handler.class})"

# --- Voice I/O ---

require_relative "../lib/voice/speaker"

speaker = Speaker.new(logger: $logger, enabled: ENV["VOICE"] != "off")
speaker.attach(bus)
$logger.info "Speaker attached (enabled: #{ENV["VOICE"] != "off"})"

# --- VSM Capsule (Layer 5) ---

require_relative "../lib/departments"
require_relative "../lib/vsm/intelligence"
require_relative "../lib/vsm/operations"

fire    = FireDepartment.new
police  = PoliceDepartment.new
ems     = EMS.new
utils   = Utilities.new
council = CityCouncil.new

intelligence = Intelligence.new(logger: $logger)
intelligence.attach(bus)
$logger.info "Intelligence attached"

operations = Operations.new(logger: $logger)
[fire, police, ems, utils, council].each { |dept| operations.register(dept) }
operations.attach(bus)
$logger.info "Operations attached with #{[fire, police, ems, utils, council].size} departments"

# --- Autonomy (Layer 4) ---

require_relative "../lib/autonomy/governance"
require_relative "../lib/autonomy/chaos_bridge"
require_relative "../lib/autonomy/self_agency_bridge"

governance = Governance.new(logger: $logger)
governance.attach(bus)
$logger.info "Governance attached"

# Code generation robot (robot_lab)
require "robot_lab"
code_gen_robot = RobotLab.build(
  name: "code_generator",
  system_prompt: "You are a Ruby code generator for a 911 dispatch system. Generate ONLY def...end method definitions. No class wrappers. No explanations. Methods must be safe â€” no system/exec/eval/File/IO.",
  temperature: 0.3
)

chaos = ChaosBridge.new(robot: code_gen_robot, logger: $logger)
chaos.attach(bus)
chaos.watch(FireDepartment)
chaos.watch(PoliceDepartment)
chaos.watch(EMS)
chaos.watch(Utilities)
chaos.watch(CityCouncil)
$logger.info "ChaosBridge attached (watching 5 department classes)"

agency = SelfAgencyBridge.new(robot: code_gen_robot, logger: $logger)
agency.attach(bus)
$logger.info "SelfAgencyBridge attached"

# --- Web Dashboard ---

require_relative "../lib/web/display_bridge"
require_relative "../web/app"

display_bridge = DisplayBridge.new
display_bridge.attach(bus)

dashboard_port = ENV.fetch("DASHBOARD_PORT", "4567").to_i
DashboardApp.set :bridge, display_bridge
DashboardApp.set :bus, bus
DashboardApp.set :port, dashboard_port
DashboardApp.set :bind, "0.0.0.0"
DashboardApp.set :environment, :production

web_thread = Thread.new do
  DashboardApp.run!
rescue => e
  $logger.error "Dashboard error: #{e.message}"
end

$logger.info "Dashboard starting on http://localhost:#{dashboard_port}"

# --- Scenario Player ---

require_relative "../lib/scenario/player"

calls_path = ENV.fetch("DEMO_CALLS", File.expand_path("../scenarios/demo_calls.yml", __dir__))

player = ScenarioPlayer.new(scenario_path: calls_path, logger: $logger)
player.attach(bus)
player.on_phase { |name| $logger.info "=== PHASE: #{name} ===" }
$logger.info "ScenarioPlayer loaded (#{calls_path})"

# --- Signal handling ---

shutdown = false

%w[TERM INT].each do |sig|
  trap(sig) do
    shutdown = true
  end
end

# --- Main loop ---

$logger.info "Demo ready, starting scenario..."

Async do
  # Play the scenario in a background task
  scenario_task = Async do
    player.play
    $logger.info "Scenario playback finished"
  end

  # Wait for scenario to finish or shutdown signal
  loop do
    break if shutdown
    break if scenario_task.finished?
    sleep 0.25
  end

  # Allow time for final messages to propagate
  sleep 1 unless shutdown
end

# --- Cleanup ---

$logger.info "Shutting down..."
handler.close if handler.respond_to?(:close)
bus.close_all
$logger.info "Demo stopped."
$logger.close
